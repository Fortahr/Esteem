#pragma once

//ORIGINAL NOTE:
/* Copyright (c) 2007-2012 Eliot Eshelman
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*
*/

/* 2D, 3D and 4D Simplex Noise functions return 'random' values in (-1, 1).

This algorithm was originally designed by Ken Perlin, but my code has been
adapted from the implementation written by Stefan Gustavson (stegu@itn.liu.se)

Raw Simplex noise functions return the value generated by Ken's algorithm.

Scaled Raw Simplex noise functions adjust the range of values returned from the
traditional (-1, 1) to whichever bounds are passed to the function.

Multi-Octave Simplex noise functions compine multiple noise values to create a
more complex result. Each successive layer of noise is adjusted and scaled.

Scaled Multi-Octave Simplex noise functions scale the values returned from the
traditional (-1,1) range to whichever range is passed to the function.

In many cases, you may think you only need a 1D noise function, but in practice
2D  is almost always better.  For instance, if you're using the current frame
number  as the parameter for the noise, all objects will end up with the same
noise value  at each frame. By adding a second parameter on the second
dimension, you can ensure that each gets a unique noise value and they don't
all look identical.
*/

#include <numeric>
#include <random>
#include <algorithm>
#include <iterator>

namespace Esteem
{
	namespace noise
	{
		class Simplex
		{
		public:
			Simplex(const float octaves,
							const float persistence,
							const float scale,
							const int seed = 0,
							const float lowerBound = -1,
							const float upperBound = 1) :
				octaves(octaves),
				persistence(persistence),
				scale(scale),
				lowerBound(lowerBound),
				upperBound(upperBound)
			{
				//create iterators
				auto begin = std::begin(perm);
				auto mid = begin + 256;
				auto end = std::end(perm);

				//fill table with number sequence (twice the [0:255] range)
				std::iota(begin, mid, 0);		//[0:255]
				std::iota(mid, end, 0);	//[0:255]

				//shuffle list based on seed
				std::shuffle(begin, end, std::default_random_engine(seed));
			}

		public:
			// Multi-octave Simplex noise
			// For each octave, a higher frequency/lower amplitude function will be added to the original.
			// The higher the persistence [0-1], the more of each succeeding octave will be added.
			float OctaveNoise2D(const float x, const float y) const;
			float OctaveNoise3D(const float x, const float y, const float z) const;
			float OctaveNoise4D(const float x, const float y, const float z, const float w) const;

		public:
			// Scaled Multi-octave Simplex noise
			// The result will be between the two parameters passed.
			float ScaledOctaveNoise2D(const float x,
																const float y) const;
			float ScaledOctaveNoise3D(const float x,
																const float y,
																const float z) const;
			float ScaledOctaveNoise4D(const float x,
																const float y,
																const float z,
																const float w) const;
		public:
			// Scaled Raw Simplex noise
			// The result will be between the two parameters passed.
			float ScaledRawNoise2D(const float x,
														 const float y) const;
			float ScaledRawNoise3D(const float x,
														 const float y,
														 const float z) const;
			float ScaledRawNoise4D(const float x,
														 const float y,
														 const float z,
														 const float w) const;

		public:
			// Raw Simplex noise - a single noise value.
			float RawNoise2D(const float x, const float y) const;
			float RawNoise3D(const float x, const float y, const float z) const;
			float RawNoise4D(const float x, const float y, const float, const float w) const;


		private: //utility functions
			inline int fastfloor(const float x) const
			{ return x > 0 ? (int)x : (int)x - 1; }

			inline float dot(const int* g, const float x, const float y) const
			{ return g[0] * x + g[1] * y; }
			inline float dot(const int* g, const float x, const float y, const float z) const
			{ return g[0] * x + g[1] * y + g[2] * z; }
			inline float dot(const int* g, const float x, const float y, const float z, const float w) const
			{ return g[0] * x + g[1] * y + g[2] * z + g[3] * w; }

		private: //generator settings
			const float octaves;
			const float persistence;
			const float scale;
			const float lowerBound;
			const float upperBound;

			int perm[512];
		};
	}
}